Here are the reusable OPA policies tailored for AWS Lambda resources, structured to evaluate the Terraform `plan.json` output based on the specified operational best practices.

### Reusable OPA Policies for AWS Lambda

```rego
package aws.lambda.policies

# 1. Enforce Lambda Concurrency Check
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    resource.change.after.concurrency_limit == 0
    msg = sprintf("Lambda function '%s' does not have a concurrency limit set", [resource.change.after.function_name])
}

# 2. Enforce Dead Letter Queue Check
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    not resource.change.after.dead_letter_config
    msg = sprintf("Lambda function '%s' does not have a Dead Letter Queue configured", [resource.change.after.function_name])
}

# 3. Enforce Public Access Prohibition for Lambda Functions
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    resource.change.after.public_access == true
    msg = sprintf("Lambda function '%s' is publicly accessible", [resource.change.after.function_name])
}

# 4. Enforce Lambda Function Settings Check
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    resource.change.after.timeout > 900  # Timeout greater than 15 minutes
    msg = sprintf("Lambda function '%s' has a timeout exceeding the allowed limit", [resource.change.after.function_name])
}

# 5. Enforce Lambda Inside VPC
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    not resource.change.after.vpc_config
    msg = sprintf("Lambda function '%s' is not configured to run inside a VPC", [resource.change.after.function_name])
}

# 6. Enforce Lambda VPC Multi-AZ Check
deny[msg] {
    resource := input.resource_changes[_]
    resource.type == "aws_lambda_function"
    not resource.change.after.vpc_config.subnet_ids[_] == "multi-az"
    msg = sprintf("Lambda function '%s' is not deployed in a multi-AZ subnet configuration", [resource.change.after.function_name])
}

# Allow if no deny conditions are met
allow {
    not deny[_]
}
```

### Explanation of Policy Structure

- Each policy rule checks a specific compliance requirement related to Lambda resources.
- The rules are structured to evaluate the changes described in the `resource_changes` array of the `plan.json` generated by Terraform.
- The `deny` statement is used to generate messages when compliance checks fail.
- The `allow` rule permits the resource changes if no deny conditions are triggered.

### Usage

You can run the evaluation against your `plan.json` output file generated from your Terraform plans. The command would look like this:

```bash
opa eval -i plan.json -d policy.rego "data.aws.lambda.policies.allow"
```

This format allows you to efficiently integrate these Lambda policies within your existing Terraform workflows and ensure that Lambda configurations comply with established best practices before deployment.
